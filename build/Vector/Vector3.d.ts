export interface IVector3Json {
    x: number;
    y: number;
    z: number;
}
export interface IVector3 extends Float32Array, IVector3Json {
}
export default class Vector3 extends Float32Array implements IVector3 {
    static readonly VECTOR3_ZERO: Vector3;
    static readonly VECTOR3_ONE: Vector3;
    static readonly VECTOR3_TOP: Vector3;
    static readonly VECTOR3_BOTTOM: Vector3;
    static readonly VECTOR3_LEFT: Vector3;
    static readonly VECTOR3_RIGHT: Vector3;
    static readonly VECTOR3_FRONT: Vector3;
    static readonly VECTOR3_BACK: Vector3;
    static add: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static addScalar: (a: Float32Array | IVector3 | number[], b: number, out?: IVector3) => IVector3;
    static angle: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => number;
    static clamp: (a: Float32Array | IVector3 | number[], min: Float32Array | IVector3 | number[], max: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static clampSafe: (a: Float32Array | IVector3 | number[], min: Float32Array | IVector3 | number[], max: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static clampScalar: (a: Float32Array | IVector3 | number[], min: number, max: number, out?: IVector3) => IVector3;
    static clone: (a: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static closeTo: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => boolean;
    static create: (x?: number, y?: number, z?: number, out?: IVector3) => IVector3;
    static cross: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static distanceTo: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => number;
    static distanceToManhattan: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => number;
    static distanceToSquared: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => number;
    static divide: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static divideScalar: (a: Float32Array | IVector3 | number[], b: number, out?: IVector3) => IVector3;
    static dot: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => number;
    static equals: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[]) => boolean;
    static fromArray: (a: ArrayLike<number> | IVector3 | number[], offset?: number, out?: IVector3) => IVector3;
    static fromScalar: (num: number, out?: IVector3) => IVector3;
    static fromValues: (x: number, y: number, z: number, out?: IVector3) => IVector3;
    static hermite: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], c: Float32Array | IVector3 | number[], d: Float32Array | IVector3 | number[], t: number, out?: IVector3) => IVector3;
    static inverse: (a: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static norm: (a: Float32Array | IVector3 | number[]) => number;
    static lengthManhattan: (a: Float32Array | IVector3 | number[]) => number;
    static lengthSquared: (a: Float32Array | IVector3 | number[]) => number;
    static lerp: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], alpha: number, out?: IVector3) => IVector3;
    static max: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static min: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static minus: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static minusScalar: (a: Float32Array | IVector3 | number[], b: number, out?: IVector3) => IVector3;
    static multiply: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static multiplyScalar: (a: Float32Array | IVector3 | number[], scalar: number, out?: IVector3) => IVector3;
    static negate: (a: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static normalize: (a: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static rotateX: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], rad: number, out?: IVector3) => IVector3;
    static rotateY: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], rad: number, out?: IVector3) => IVector3;
    static rotateZ: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], rad: number, out?: IVector3) => IVector3;
    static round: (a: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static set: (x?: number, y?: number, z?: number, out?: IVector3) => IVector3;
    static setNorm: (a: Float32Array | IVector3 | number[], len: number, out?: IVector3) => IVector3;
    static slerp: (a: Float32Array | IVector3 | number[], b: Float32Array | IVector3 | number[], t: number, out?: IVector3) => IVector3;
    static toString: (a: Float32Array | IVector3 | number[]) => string;
    static transformMatrix3: (a: Float32Array | IVector3 | number[], m: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static transformMatrix4: (a: Float32Array | IVector3 | number[], m: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    static transformQuat: (a: Float32Array | IVector3 | number[], q: Float32Array | IVector3 | number[], out?: IVector3) => IVector3;
    readonly length: 3;
    readonly dataType: string;
    constructor(x?: number, y?: number, z?: number);
    get x(): number;
    set x(value: number);
    get y(): number;
    set y(value: number);
    get z(): number;
    set z(value: number);
}
