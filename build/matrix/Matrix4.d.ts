import { IEulerAngle } from "../euler/IEulerAngle";
import { Vector3, Vector3Like } from "../vector/Vector3";
import { Matrix3Like } from "./Matrix3";
import { Plane3 } from "../shape/Plane3";
import { QuaternionLike } from "../quaternion";
export type Matrix4Like = Matrix4 | Float32Array | number[];
export declare class Matrix4 extends Float32Array {
    static readonly UNIT_MATRIX4: Matrix4;
    static clone: <T extends Matrix4Like = Matrix4>(source: Matrix4Like, out?: T) => T;
    static create: () => Matrix4;
    static determinant: (a: Matrix4Like) => number;
    static fromArray: <T extends Matrix4Like = Matrix4>(source: Matrix4Like, out?: T) => T;
    static fromEuler: <T extends Matrix4Like = Matrix4>(euler: IEulerAngle, out?: T) => T;
    static fromMatrix3: <T extends Matrix4Like>(data: Matrix3Like, out?: T) => T;
    static fromMatrix3MVP: <T extends Matrix4Like>(data: Matrix3Like, out?: T) => T;
    static fromQuaternion: <T extends Matrix4Like>(q: QuaternionLike, out?: T) => T;
    static fromReflectPlane: <T extends Matrix4Like>(plane: Plane3, out?: T) => T;
    static fromRotation: <T extends Matrix4Like>(rad: number, axis: Vector3Like, out?: T) => T | null;
    static fromRotationX: <T extends Matrix4Like>(rad: number, out?: T) => T;
    static fromRotationY: <T extends Matrix4Like>(rad: number, out?: T) => T;
    static fromRotationZ: <T extends Matrix4Like>(rad: number, out?: T) => T;
    static fromScaling: <T extends Matrix4Like>(v: Vector3Like, out?: T) => T;
    static fromTranslation: <T extends Matrix4Like>(v: Vector3Like, out?: T) => T;
    static identity: <T extends Matrix4Like>(out?: T) => T;
    static invert: <T extends Matrix4Like>(a: Matrix4Like, out?: T) => T | null;
    static lookAt: <T extends Matrix4Like>(eye: Vector3Like, center: Vector3Like, up?: Vector3Like, out?: T) => T;
    static multiply: <T extends Matrix4Like>(a: Matrix4Like, b: Matrix4Like, out?: T) => T;
    static multiplyScaleMatrix: <T extends Matrix4Like>(a: Matrix4Like, b: Matrix4Like, out?: T) => T;
    static multiplyTranslateMatrix: <T extends Matrix4Like>(a: Matrix4Like, b: Matrix4Like, out?: T) => T;
    static orthogonal: <T extends Matrix4Like>(left: number, right: number, bottom: number, top: number, near: number, far: number, out?: T) => T;
    static orthogonalZ0: <T extends Matrix4Like>(left: number, right: number, bottom: number, top: number, near: number, far: number, out?: T) => T;
    static perspective: <T extends Matrix4Like>(fovy: number, aspect: number, near: number, far: number, out?: T) => T;
    static perspectiveZ0: <T extends Matrix4Like>(fovy: number, aspect: number, near: number, far: number, out?: T) => T;
    static rotate: <T extends Matrix4Like>(a: Matrix4Like, rad: number, axis: Vector3Like, out?: T) => T | null;
    static rotateX: <T extends Matrix4Like>(a: Matrix4Like, rad: number, out?: T) => T;
    static rotateY: <T extends Matrix4Like>(a: Matrix4Like, rad: number, out?: T) => T;
    static rotateZ: <T extends Matrix4Like>(a: Matrix4Like, rad: number, out?: T) => T;
    static scale: <T extends Matrix4Like>(a: Matrix4Like, v: Vector3Like, out?: T) => T;
    static targetTo: <T extends Matrix4Like>(eye: Vector3Like, target: Vector3Like, up?: Vector3Like, out?: T) => T;
    static translate: <T extends Matrix4Like>(a: Matrix4Like, v: Vector3Like, out?: T) => T;
    static transpose: <T extends Matrix4Like>(a: Matrix4Like, out?: T) => T;
    static unproject: <T extends Vector3Like = Vector3>(vec3: Vector3Like, projectionMatrix: Matrix4Like, worldMatrix: Matrix4Like, out?: T) => T;
    constructor(data?: Matrix4Like);
}
