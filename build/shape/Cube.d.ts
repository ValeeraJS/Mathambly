import { Vector3, IVector3, Vector3Like } from "../vector/Vector3";
import { ICube } from "./interfaces/ICube";
import { ISphere } from "./interfaces/ISphere";
import { ITriangle3 } from "./interfaces/ITriangle3";
export declare class Cube implements ICube {
    static center: <T extends Vector3Like = Vector3>(a: ICube, out?: T) => T;
    static clampPoint: <T extends Vector3Like = Vector3>(a: ICube, point: Vector3Like, out?: T) => T;
    static containsPoint: (a: ICube, b: Vector3Like) => boolean;
    static containsCube: (a: ICube, b: ICube) => boolean;
    static depth: (a: ICube) => number;
    static equals: (a: ICube, b: ICube) => boolean;
    static getSize: <T extends Vector3Like = Vector3>(a: ICube, out?: T) => T;
    static height: (a: ICube) => number;
    static intersect: (a: ICube, b: ICube, out?: Cube) => Cube;
    static intersectsBox: (a: ICube, b: ICube) => boolean;
    static intersectsSphere: (a: ICube, b: ISphere) => boolean;
    static intersectsTriangle: (a: ICube, b: ITriangle3) => boolean;
    static isEmpty: (a: ICube) => boolean;
    static round: (a: ICube, out?: Cube) => Cube;
    static size: <T extends Vector3Like = Vector3>(a: ICube, out?: T) => T;
    static stretch: (a: ICube, b: Float32Array | number[] | IVector3, c: Float32Array | number[] | IVector3, out?: Cube) => Cube;
    static surfaceArea: (a: ICube) => number;
    static translate: (a: ICube, b: Float32Array | number[] | IVector3, out?: Cube) => Cube;
    static union: (a: ICube, b: ICube, out?: Cube) => Cube;
    static volume: (a: ICube) => number;
    static width: (a: ICube) => number;
    min: Vector3;
    max: Vector3;
    constructor(a?: Vector3Like, b?: Vector3Like);
}
